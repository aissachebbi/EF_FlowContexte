h1. üöÄ [EPIC] Conception et Architecture du socle MQ2DB Engine

h2. 1. üéØ Contexte et Existant (As-Is)
Historiquement, le syst√®me s'appuie sur un composant monolithique qui √©coute une file d'attente *MQ Series*. Au fil de l'eau, les messages lus sont √©crits dans des *fichiers physiques temporaires* (fichiers tampons) sur le disque du serveur afin de constituer des lots.
Ce fonctionnement pr√©sente des limites architecturales :
* Adh√©rence forte au disque local (difficile de faire du clustering Actif-Actif).
* Probl√®mes de performance li√©s aux I/O disque.
* Reprise sur erreur complexe en cas de crash serveur pendant l'√©criture d'un fichier temporaire.

----

h2. 2. üåü Le Nouveau Paradigme (To-Be)
La nouvelle solution vise √† supprimer totalement ces fichiers tampons physiques en utilisant la *Base de Donn√©es relationnelle comme zone tampon (souche)*. Les lots ne sont plus construits sur le disque, mais de mani√®re logique en base de donn√©es.

Pour des raisons de s√©paration des responsabilit√©s, la nouvelle architecture est scind√©e en deux composants distincts :

# *Le MQ Feeder (Hors scope de cette Epic) :*
#* Responsable exclusif de l'√©coute de la queue MQ Series.
#* Il ins√®re les messages bruts directement dans la base de donn√©es (table g√©n√©rique {{CB_MSG}} et table m√©tier correspondante).
# *Le MQ2DB Engine (Le Kernel - P√©rim√®tre de cette Epic) :*
#* Le c≈ìur du r√©acteur. Il scrute la base de donn√©es, r√©cup√®re les messages asynchrones et g√®re la logique de regroupement (lotissement).
#* *Le concept de "Fichier Logique" :* Au lieu de cr√©er un fichier physique temporaire, l'Engine cr√©e une ligne dans la table {{CB_FILE}} qui repr√©sente le lot. Tous les messages ({{CB_MSG}}) valid√©s pour ce lot sont mis √† jour avec l'ID de ce fichier (Relation _Many-to-One_).
#* Une fois le fichier logique clos, il publie une notification pour pr√©venir les syst√®mes avals.

----

h2. 3. üöß Probl√©matiques et D√©fis Techniques de l'Engine
Ce nouveau moteur de lotissement ({{MQ2DB Engine}}) doit r√©pondre √† des contraintes de classe Entreprise tr√®s strictes :
* *Pr√©servation de l'Ordre (FIFO stricte) :* Les messages doivent imp√©rativement √™tre trait√©s et ins√©r√©s dans les fichiers logiques en respectant exactement leur ordre d'arriv√©e chronologique dans la base de donn√©es (ordre d'origine du MQ Series).
* *Haute Disponibilit√© (Actif-Actif) :* L'Engine doit tourner sur plusieurs serveurs simultan√©ment pour la r√©partition de charge.
* *Concurrence d'acc√®s (Z√©ro doublon) :* Si deux n≈ìuds lisent la base, ils ne doivent jamais embarquer le m√™me message dans deux lots diff√©rents.
* *Tol√©rance aux pannes :* Si un serveur crashe au milieu de la constitution d'un lot, l'√©tat d'agr√©gation ne doit pas √™tre perdu et aucun message ne doit rester bloqu√©.
* *Haute Performance :* Absorption de pics de charge extr√™mes (ex: 100 000 messages) sans congestionner la base Oracle.

----

h2. 4. üí° Architecture de la Solution (MQ2DB Engine)
Pour relever ces d√©fis, le Kernel MQ2DB s'appuie sur le framework *Spring Integration* adoss√© √† un cluster de base de donn√©es (JDBC Message Store). Il se d√©compose en 4 grands sous-syst√®mes :

# *Le Poller (Aspirateur & Verrou) :* Il scrute les messages en base au statut {{NEW}}. Il utilise la clause Oracle avanc√©e {{FOR UPDATE SKIP LOCKED}} pour verrouiller un lot de messages sans bloquer les autres instances. Il marque les messages avec un _Claim Token_ (UUID) et passe leur statut √† {{IN_PROGRESS}}.
# *L'Agr√©gateur (La Gare de Triage) :* Pilot√© par Spring Integration, il re√ßoit les messages et les trie dans des "seaux" partag√©s en cluster (par Flux et par Branche). Il attend que le seuil soit atteint (ex: 500 msgs) ou qu'un Timeout expire (ex: 2 min) pour lib√©rer le lot.
# *Le Batch Processor (Le G√©n√©rateur Logique & Garant de l'Ordre) :* Il r√©ceptionne le lot lib√©r√©. *Il effectue un tri chronologique strict (FIFO)* des messages en m√©moire, ins√®re une ligne dans {{CB_FILE}} (le fichier logique), associe cette ligne √† tous les {{CB_MSG}} du lot (relation N..1), passe le statut √† {{DONE}}, et d√©clenche une notification via Oracle AQ.
# *Les Reapers (L'Auto-Gu√©rison) :* Des processus de fond (watchdogs) qui surveillent les anomalies. Si des messages restent bloqu√©s {{IN_PROGRESS}} trop longtemps (ex: crash mat√©riel d'une instance), le Reaper "nettoie" ces orphelins et les remet √† {{NEW}} pour √™tre repris par le cluster sain.

----

h2. 5. üó∫Ô∏è Diagrammes d'Architecture

{panel:title=Note pour les diagrammes|borderStyle=solid|borderColor=#ccc|bgColor=#f2f2f2}
G√©n√©rez les diagrammes Mermaid ci-dessous via https://mermaid.live et attachez les images √† cette Epic.
{panel}

h3. A. Vue Globale : Du MQ au Fichier Logique

{code:javascript}
graph TD
    classDef external fill:#f9f2f4,stroke:#333,stroke-width:2px;
    classDef feeder fill:#fff3cd,stroke:#856404,stroke-width:2px;
    classDef engine fill:#d4edda,stroke:#28a745,stroke-width:2px;
    classDef db fill:#e2e3e5,stroke:#383d41,stroke-width:2px;

    MQ((Queue MQ Series)) class MQ external;

    subgraph "Partie 1 (Hors Scope)"
        Feed[Composant Feeder] class Feed feeder;
    end

    subgraph "Base de Donn√©es Oracle (Souche & Logique)"
        CBMSG[Table CB_MSG<br/>Messages unitaires] class CBMSG db;
        CBFILE[Table CB_FILE<br/>Fichiers Logiques] class CBFILE db;
        STORE[Tables EF_INT_MESSAGE<br/>√âtat d'agr√©gation] class STORE db;
    end

    subgraph "Partie 2 : MQ2DB Engine (P√©rim√®tre)"
        Node1[Instance 1] class Node1 engine;
        Node2[Instance 2] class Node2 engine;
    end

    AQ[[Oracle AQ<br/>Notifications]] class AQ external;

    MQ -->|Consomme| Feed
    Feed -->|Insert| CBMSG

    CBMSG -->|Poll (SKIP LOCKED)| Node1
    CBMSG -->|Poll (SKIP LOCKED)| Node2

    Node1 <-->|Coordination de l'agr√©gation| STORE
    Node2 <-->|Coordination de l'agr√©gation| STORE

    Node1 -->|1. Tri FIFO & Cr√©ation Lot Logique| CBFILE
    Node2 -->|1. Tri FIFO & Cr√©ation Lot Logique| CBFILE

    CBMSG -.->|Relation Many-To-One<br/>Mise √† jour statut DONE| CBFILE

    Node1 -->|2. Notifie| AQ
    Node2 -->|2. Notifie| AQ
{code}

h3. B. Cycle de Vie d'un Message (Workflow)

{code:javascript}
stateDiagram-v2
    direction LR

    state "NEW" as new
    state "IN_PROGRESS" as inprog
    state "DONE" as done

    [*] --> new : Ins√©r√© par le Feeder (Ordre MQ)

    new --> inprog : 1. POLLER (Aspiration par un n≈ìud)\n[Ajout du Claim Token]

    state inprog {
        [*] --> Splitter : Traitement unitaire
        Splitter --> Aggregator : Stock√© en base (EF_INT_MESSAGE)
        Aggregator --> [*] : Seuil de 500 atteint\nou Timeout 2min
    }

    inprog --> done : 2. PROCESSOR (G√©n√©ration)\n[Tri strict FIFO + Cr√©ation CB_FILE]

    inprog --> new : 3. REAPER (S√©curit√©)\n[Si N≈ìud crash > 30 min]

    done --> [*] : Notification AQ envoy√©e
{code}